# .github/workflows/frontEndWeb-e2e.yml
# üß™ Testes E2E FrontEndWeb com Cypress

name: Testes E2E üß™ - FrontEndWeb

on:
  push:
    paths:
      - 'code/frontEndWeb/**'
      - 'code/backend/**'  # Backend tamb√©m afeta E2E
      - 'code/frontEndWeb/cypress/**'
    branches-ignore:
      - 'dependabot/**'
  pull_request:
    paths:
      - 'code/frontEndWeb/**'
      - 'code/backend/**'
      - 'code/frontEndWeb/cypress/**'

env:
  # Configura√ß√µes do ambiente de teste
  FRONTENDWEB_URL: http://localhost:5173
  BACKEND_URL: http://localhost:8080
  DB_HOST: localhost
  DB_PORT: 3306
  DB_NAME: carpool_test_e2e
  DB_USERNAME: test_user
  DB_PASSWORD: test_password
  DB_ROOT_PASSWORD: root_password
  
  # Configura√ß√µes espec√≠ficas do Cypress
  CYPRESS_baseUrl: http://localhost:5173
  CYPRESS_apiUrl: http://localhost:8080/api
  CYPRESS_adminEmail: admin@carona.com
  CYPRESS_adminPassword: admin123
  CYPRESS_adminHashedPassword: '$2a$10$8RdQFz7J9GqVQ4ZxFzQJZuNnQqQJrQrL5rQxKxqF1xLnNnLjYKqJ2'
  
  # Configura√ß√µes do CI
  CI: true
  NODE_ENV: test

jobs:
  # üéØ Testes r√°pidos de smoke
  smoke-tests:
    if: (github.event_name != 'pull_request' && ! github.event.pull_request.head.repo.fork) || (github.event_name == 'pull_request' && (github.event.pull_request.head.repo.fork || startsWith(github.head_ref, 'dependabot/')))
    runs-on: ubuntu-latest
    name: üéØ Smoke Tests
    
    permissions:
      contents: read
      checks: write
      pull-requests: write

    steps:
      - name: üì• Checando c√≥digo fonte
        uses: actions/checkout@v4

      - name: üü¢ Configurando Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: üì¶ Instalando depend√™ncias do FrontEndWeb
        working-directory: ./code/frontEndWeb
        run: |
          # Verificar se package-lock.json existe
          if [ ! -f "package-lock.json" ]; then
            echo "‚ùå package-lock.json n√£o encontrado. Executando npm install..."
            npm install
          else
            echo "‚úÖ package-lock.json encontrado. Executando npm ci..."
            npm ci
          fi

      - name: üß™ Executando Smoke Tests
        working-directory: ./code/frontEndWeb
        run: |
          # Build da aplica√ß√£o primeiro
          echo "üèóÔ∏è Building aplica√ß√£o..."
          npm run build
          
          # Iniciar preview da aplica√ß√£o para smoke tests
          echo "üåê Iniciando preview..."
          nohup npm run preview > ../smoke-preview.log 2>&1 &
          
          # Aguardar preview estar pronto
          echo "‚è≥ Aguardando preview estar pronto..."
          timeout 30 bash -c 'until curl -f http://localhost:4173 2>/dev/null; do sleep 1; done' || {
            echo "‚ùå Preview n√£o ficou pronto. Logs:"
            tail -10 ../smoke-preview.log
            exit 1
          }
          echo "‚úÖ Preview est√° pronto!"
          
          # Executar apenas testes b√°sicos sem backend
          echo "üß™ Executando smoke tests..."
          npx cypress run \
            --spec "cypress/e2e/auth/login.cy.js" \
            --browser chrome \
            --headless \
            --config "baseUrl=http://localhost:4173,video=false,screenshotOnRunFailure=true,defaultCommandTimeout=5000" \
            --env "skipApiTests=true,CI=true" || {
            echo "‚ùå Smoke tests falharam"
            echo "üìã Logs do preview:"
            tail -20 ../smoke-preview.log
            exit 1
          }
          echo "‚úÖ Smoke tests conclu√≠dos!"

      - name: üìä Upload de artefatos em caso de falha
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: smoke-test-artifacts
          path: |
            code/frontEndWeb/cypress/screenshots
            code/frontEndWeb/cypress/videos
          retention-days: 3

  # üß™ Testes E2E completos
  e2e-tests:
    if: (github.event_name != 'pull_request' && ! github.event.pull_request.head.repo.fork) || (github.event_name == 'pull_request' && (github.event.pull_request.head.repo.fork || startsWith(github.head_ref, 'dependabot/')))
    runs-on: ubuntu-latest
    name: üß™ E2E Tests
    
    permissions:
      contents: read
      checks: write
      pull-requests: write
      statuses: write

    # üìã Estrat√©gia de matriz para diferentes browsers
    strategy:
      fail-fast: false
      matrix:
        browser: [chrome, firefox]
        include:
          - browser: chrome
            port_offset: 0
          - browser: firefox
            port_offset: 10

    steps:
      - name: üì• Checando c√≥digo fonte
        uses: actions/checkout@v4

      - name: üîß Configurando portas din√¢micas
        run: |
          # Calcular portas baseadas no offset da matrix
          PORT_OFFSET=${{ matrix.port_offset }}
          
          # Calcular portas din√¢micas
          MYSQL_PORT=$((3306 + PORT_OFFSET))
          RABBITMQ_PORT=$((5672 + PORT_OFFSET))
          RABBITMQ_MGMT_PORT=$((15672 + PORT_OFFSET))
          BACKEND_PORT=$((8080 + PORT_OFFSET))
          
          # Salvar como vari√°veis de ambiente para pr√≥ximos steps
          echo "MYSQL_PORT=$MYSQL_PORT" >> $GITHUB_ENV
          echo "RABBITMQ_PORT=$RABBITMQ_PORT" >> $GITHUB_ENV
          echo "RABBITMQ_MGMT_PORT=$RABBITMQ_MGMT_PORT" >> $GITHUB_ENV
          echo "BACKEND_PORT=$BACKEND_PORT" >> $GITHUB_ENV
          
          echo "üîß Portas configuradas:"
          echo "  MySQL: $MYSQL_PORT"
          echo "  RabbitMQ: $RABBITMQ_PORT"
          echo "  RabbitMQ Management: $RABBITMQ_MGMT_PORT"
          echo "  Backend: $BACKEND_PORT"

      - name: üü¢ Configurando Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: üê≥ Instalando Docker Compose
        run: |
          # Verificar se docker compose est√° dispon√≠vel
          if ! docker compose version >/dev/null 2>&1; then
            echo "Docker Compose V2 n√£o encontrado, instalando docker-compose..."
            sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            echo "docker-compose instalado:"
            docker-compose --version
          else
            echo "Docker Compose V2 dispon√≠vel:"
            docker compose version
          fi

      - name: ‚òï Configurando JDK 21
        uses: actions/setup-java@v4
        with: 
          distribution: 'temurin'
          java-version: '21'

      - name: üîß Configurando cache do Maven
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven

      - name: üì¶ Instalando depend√™ncias do FrontEndWeb
        working-directory: ./code/frontEndWeb
        run: |
          echo "üîç Debug: Verificando estrutura de arquivos..."
          pwd
          ls -la
          echo "üì¶ Verificando package.json e package-lock.json..."
          ls -la package* || echo "Arquivos package n√£o encontrados"
          
          # Verificar se package-lock.json existe
          if [ ! -f "package-lock.json" ]; then
            echo "‚ùå package-lock.json n√£o encontrado. Executando npm install..."
            npm install
          else
            echo "‚úÖ package-lock.json encontrado. Executando npm ci..."
            npm ci
          fi
          npm run build

      - name: üê≥ Iniciando servi√ßos Docker
        run: |
          # Verificar se arquivo docker-compose existe
          if [ ! -f "docker-compose-e2e.yml" ]; then
            echo "‚ùå Arquivo docker-compose-e2e.yml n√£o encontrado"
            echo "üìÇ Conte√∫do do diret√≥rio atual:"
            pwd
            ls -la
            exit 1
          fi
          
          # Iniciar servi√ßos com portas din√¢micas
          docker compose -f docker-compose-e2e.yml up -d
          
          # Fun√ß√£o para verificar sa√∫de de servi√ßos espec√≠ficos
          check_service() {
            local service=$1
            local max_attempts=30
            local attempt=1
            
            echo "Verificando servi√ßo: $service"
            while [ $attempt -le $max_attempts ]; do
              if docker compose -f docker-compose-e2e.yml ps $service | grep -q "healthy"; then
                echo "‚úÖ $service est√° saud√°vel"
                return 0
              fi
              echo "‚è≥ Tentativa $attempt/$max_attempts - Aguardando $service..."
              sleep 4
              attempt=$((attempt + 1))
            done
            
            echo "‚ùå $service n√£o ficou saud√°vel ap√≥s $max_attempts tentativas"
            docker compose -f docker-compose-e2e.yml logs $service
            return 1
          }
          
          # Verificar cada servi√ßo individualmente
          for service in mysql rabbitmq; do
            if ! check_service $service; then
              echo "‚ùå Falha ao inicializar $service"
              docker compose -f docker-compose-e2e.yml logs
              docker compose -f docker-compose-e2e.yml down -v
              exit 1
            fi
          done
          
          echo "‚úÖ Todos os servi√ßos est√£o saud√°veis!"
          docker compose -f docker-compose-e2e.yml ps
        env:
          DB_ROOT_PASSWORD: ${{ env.DB_ROOT_PASSWORD || 'root_password' }}
          DB_NAME: ${{ env.DB_NAME || 'carpool_test_e2e' }}
          DB_USERNAME: ${{ env.DB_USERNAME || 'test_user' }}
          DB_PASSWORD: ${{ env.DB_PASSWORD || 'test_password' }}
          DB_PORT: ${{ env.MYSQL_PORT || '3306' }}
          RABBITMQ_PORT: ${{ env.RABBITMQ_PORT || '5672' }}
          RABBITMQ_MGMT_PORT: ${{ env.RABBITMQ_MGMT_PORT || '15672' }}

      - name: üå± Preparando dados de teste
        run: |
          echo "Verificando conectividade com MySQL..."
          
          # Fun√ß√£o para tentar conex√£o MySQL com retry
          try_mysql_connection() {
            local max_attempts=30
            local attempt=1
            local wait_time=5
            
            while [ $attempt -le $max_attempts ]; do
              echo "Tentativa $attempt de $max_attempts para conectar ao MySQL..."
              
              if mysql --protocol=TCP -h localhost -P $MYSQL_PORT -u root -p${{ env.DB_ROOT_PASSWORD }} \
                 -e "SELECT 1" > /dev/null 2>&1; then
                echo "‚úÖ Conex√£o MySQL estabelecida!"
                return 0
              fi
              
              echo "‚è≥ Aguardando $wait_time segundos antes da pr√≥xima tentativa..."
              sleep $wait_time
              attempt=$((attempt + 1))
            done
            
            echo "‚ùå N√£o foi poss√≠vel estabelecer conex√£o com MySQL ap√≥s $max_attempts tentativas"
            return 1
          }
          
          # Tentar estabelecer conex√£o
          if ! try_mysql_connection; then
            echo "‚ùå Erro conectando ao MySQL. Verificando status dos containers..."
            docker compose -f docker-compose-e2e.yml logs mysql
            exit 1
          fi
          
          # Preparar banco de dados
          mysql --protocol=TCP -h localhost -P $MYSQL_PORT -u root -p${{ env.DB_ROOT_PASSWORD }} -e "
            CREATE DATABASE IF NOT EXISTS ${{ env.DB_NAME }};
            CREATE USER IF NOT EXISTS '${{ env.DB_USERNAME }}'@'%' IDENTIFIED BY '${{ env.DB_PASSWORD }}';
            GRANT ALL PRIVILEGES ON ${{ env.DB_NAME }}.* TO '${{ env.DB_USERNAME }}'@'%';
            FLUSH PRIVILEGES;
            USE ${{ env.DB_NAME }};
          "
          
          echo "‚úÖ Dados de teste preparados!"

      - name: üöÄ Iniciando Backend
        working-directory: ./code/backend
        env:
          SUPABASE_API_KEY: dummy-key-for-testing
          SUPABASE_PROJECT_CODE: dummy-project
          SUPABASE_USERPHOTOS_BUCKET_NAME: userphotos
        run: |
          # Compilar aplica√ß√£o primeiro
          mvn clean compile -DskipTests -q
          
          # Criar arquivo tempor√°rio de credenciais FCM para testes
          echo '{"type": "service_account","project_id": "dummy"}' > dummy-credentials.json
          
          # Iniciar aplica√ß√£o em background com perfil customizado para E2E
          nohup mvn spring-boot:run \
            -Dspring-boot.run.jvmArguments="\
              -Dspring.profiles.active=e2e \
              -Dspring.datasource.url=jdbc:mysql://localhost:$MYSQL_PORT/${{ env.DB_NAME }} \
              -Dspring.datasource.username=${{ env.DB_USERNAME }} \
              -Dspring.datasource.password=${{ env.DB_PASSWORD }} \
              -Dspring.rabbitmq.host=localhost \
              -Dspring.rabbitmq.port=$RABBITMQ_PORT \
              -Dspring.rabbitmq.username=guest \
              -Dspring.rabbitmq.password=guest \
              -Dspring.rabbitmq.virtual-host=/ \
              -Dsupabase.api-key=${SUPABASE_API_KEY} \
              -Dsupabase.code=${SUPABASE_PROJECT_CODE} \
              -Dsupabase.userphotos-bucket-name=${SUPABASE_USERPHOTOS_BUCKET_NAME} \
              -Dfcm.credentials-file=dummy-credentials.json \
              -Dfcm.project-name=carona-test \
              -Dfcm.base-url=https://fcm.googleapis.com/v1/ \
              -Dapp.cors.allowed-origins=http://localhost:5173 \
              -Dspring.jpa.hibernate.ddl-auto=create-drop \
              -Dspring.jpa.show-sql=false \
              -Dlogging.level.com.br.puc.carona=INFO \
              -Dserver.port=$BACKEND_PORT" \
            > ../backend.log 2>&1 &
          
          # Aguardar backend estar pronto
          echo "Aguardando backend estar pronto na porta $BACKEND_PORT..."
          timeout 120 bash -c "until curl -f http://localhost:$BACKEND_PORT/actuator/health 2>/dev/null; do sleep 2; done" || {
            echo "Backend n√£o ficou pronto a tempo. Verificando logs..."
            tail -50 ../backend.log
            exit 1
          }
          echo "Backend est√° pronto!"
        timeout-minutes: 5

      - name: üåê Iniciando FrontEndWeb
        working-directory: ./code/frontEndWeb
        run: |
          # Configurar vari√°vel de ambiente para apontar para o backend com porta din√¢mica
          export VITE_API_BASE_URL="http://localhost:$BACKEND_PORT"
          
          # Iniciar frontEndWeb em background  
          nohup npm run dev -- --host 0.0.0.0 --port 5173 > ../frontEndWeb.log 2>&1 &
          
          # Aguardar frontEndWeb estar pronto
          echo "Aguardando frontend estar pronto..."
          timeout 60 bash -c 'until curl -f http://localhost:5173 2>/dev/null; do sleep 2; done' || {
            echo "Frontend n√£o ficou pronto a tempo. Verificando logs..."
            tail -50 ../frontEndWeb.log
            exit 1
          }
          echo "FrontEndWeb est√° pronto!"
        timeout-minutes: 3

      - name: üß™ Executando testes Cypress
        uses: cypress-io/github-action@v6
        with:
          working-directory: ./code/frontEndWeb
          install: false
          command: |
            # Verificar se servi√ßos est√£o respondendo antes dos testes
            echo "üîç Verificando servi√ßos antes dos testes..."
            
            # Verificar frontend
            if ! curl -f http://localhost:5173 >/dev/null 2>&1; then
              echo "‚ùå Frontend n√£o est√° respondendo"
              echo "üìã Logs do frontend:"
              tail -20 ../frontEndWeb.log
              exit 1
            fi
            echo "‚úÖ Frontend est√° respondendo"
            
            # Verificar backend
            if ! curl -f http://localhost:$BACKEND_PORT/actuator/health >/dev/null 2>&1; then
              echo "‚ùå Backend n√£o est√° respondendo na porta $BACKEND_PORT"
              echo "üìã Logs do backend:"
              tail -20 ../backend.log
              exit 1
            fi
            echo "‚úÖ Backend est√° respondendo na porta $BACKEND_PORT"
            
            # Verificar MySQL
            if ! mysqladmin ping -h localhost -P $MYSQL_PORT --silent; then
              echo "‚ùå MySQL n√£o est√° respondendo na porta $MYSQL_PORT"
              exit 1
            fi
            echo "‚úÖ MySQL est√° respondendo na porta $MYSQL_PORT"
            
            # Verificar RabbitMQ
            if ! curl -f http://localhost:$RABBITMQ_MGMT_PORT >/dev/null 2>&1; then
              echo "‚ùå RabbitMQ Management n√£o est√° respondendo na porta $RABBITMQ_MGMT_PORT"
              exit 1
            fi
            echo "‚úÖ RabbitMQ est√° respondendo na porta $RABBITMQ_MGMT_PORT"
            
            echo "üöÄ Todos os servi√ßos est√£o prontos! Iniciando testes..."
            
            # Executar testes Cypress com portas din√¢micas
            npx cypress run \
              --browser ${{ matrix.browser }} \
              --config "baseUrl=http://localhost:5173,defaultCommandTimeout=10000,requestTimeout=15000,responseTimeout=15000,video=true,screenshotOnRunFailure=true" \
              --env "apiUrl=http://localhost:$BACKEND_PORT,adminEmail=${{ env.CYPRESS_adminEmail }},adminPassword=${{ env.CYPRESS_adminPassword }},CI=true"
        env:
          CYPRESS_baseUrl: ${{ env.CYPRESS_baseUrl }}
          CYPRESS_apiUrl: http://localhost:${{ env.BACKEND_PORT }}
          CYPRESS_adminEmail: ${{ env.CYPRESS_adminEmail }}
          CYPRESS_adminPassword: ${{ env.CYPRESS_adminPassword }}
          CI: true

      - name: üìä Upload de artefatos Cypress
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: cypress-artifacts-${{ matrix.browser }}
          path: |
            code/frontEndWeb/cypress/videos
            code/frontEndWeb/cypress/screenshots
          retention-days: 7

      - name: üìù Upload de logs dos servidores
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: server-logs-${{ matrix.browser }}
          path: |
            backend.log
            frontEndWeb.log
          retention-days: 3

      - name: üìã Comentando resultados no PR
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request' && (success() || failure())
        with:
          script: |
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('üß™ Resultados dos Testes E2E')
            );
            
            const status = '${{ job.status }}' === 'success' ? '‚úÖ PASSOU' : '‚ùå FALHOU';
            const emoji = '${{ job.status }}' === 'success' ? 'üéâ' : 'üí•';
            
            const body = `## üß™ Resultados dos Testes E2E - ${{ matrix.browser }}
            
            **Status**: ${status}
            **Browser**: ${{ matrix.browser }}
            **Commit**: ${context.sha.substring(0, 7)}
            **Workflow**: [Ver detalhes](${context.payload.repository.html_url}/actions/runs/${context.runId})
            
            ${
              '${{ job.status }}' !== 'success' 
                ? 'üìä Verifique os artefatos para v√≠deos e screenshots das falhas.' 
                : 'üéâ Todos os testes passaram com sucesso!'
            }
            
            ### üìã Su√≠tes Testadas
            - üîê Autentica√ß√£o e Login
            - üè† Dashboard Principal  
            - üë• Aprova√ß√£o de Usu√°rios
            - üë§ Gerenciamento de Usu√°rios
            - üìä M√©tricas e Relat√≥rios
            
            ${emoji}
            `;
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      - name: üìà Gerando resumo dos testes
        if: always()
        run: |
          echo "## üß™ Resumo dos Testes E2E" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Informa√ß√£o | Valor |" >> $GITHUB_STEP_SUMMARY
          echo "| ---------- | ----- |" >> $GITHUB_STEP_SUMMARY
          echo "| Browser | ${{ matrix.browser }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Port Offset | ${{ matrix.port_offset }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Status | ${{ job.status == 'success' && '‚úÖ Passou' || '‚ùå Falhou' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| FrontEndWeb | http://localhost:5173 |" >> $GITHUB_STEP_SUMMARY
          echo "| Backend | http://localhost:$BACKEND_PORT |" >> $GITHUB_STEP_SUMMARY
          echo "| Database | MySQL 8.0 (port $MYSQL_PORT) |" >> $GITHUB_STEP_SUMMARY
          echo "| RabbitMQ | 3-management (port $RABBITMQ_MGMT_PORT) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" != "success" ]; then
            echo "### üîç Debug" >> $GITHUB_STEP_SUMMARY
            echo "- Verifique os logs dos servidores nos artefatos" >> $GITHUB_STEP_SUMMARY
            echo "- Screenshots e v√≠deos est√£o dispon√≠veis para an√°lise" >> $GITHUB_STEP_SUMMARY
            echo "- Execute localmente: \`npm run cypress:web\`" >> $GITHUB_STEP_SUMMARY
            echo "- Logs de debug: backend.log, frontEndWeb.log" >> $GITHUB_STEP_SUMMARY
          else
            echo "### üéâ Sucesso!" >> $GITHUB_STEP_SUMMARY
            echo "Todos os testes E2E passaram com sucesso!" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Frontend funcionando corretamente" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Backend respondendo adequadamente" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Integra√ß√£o MySQL funcionando" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ RabbitMQ configurado corretamente" >> $GITHUB_STEP_SUMMARY
          fi

      - name: üßπ Limpeza dos recursos Docker
        if: always()
        run: |
          echo "Parando e removendo containers Docker..."
          docker compose -f docker-compose-e2e.yml down -v --remove-orphans || true
          
          # Remover volumes √≥rf√£os
          docker volume prune -f || true
          
          echo "‚úÖ Limpeza conclu√≠da!"

# üìã RESUMO DO PIPELINE E2E:
# 
# Este workflow executa testes end-to-end completos para o sistema carpool:
#
# üéØ SMOKE TESTS:
# - Testa apenas o frontend em modo preview
# - N√£o requer backend/database
# - Execu√ß√£o r√°pida para valida√ß√£o b√°sica
#
# üß™ E2E TESTS COMPLETOS:
# - MySQL 8.0 como banco de dados
# - RabbitMQ 3-management para mensageria  
# - Backend Spring Boot com perfil E2E
# - Frontend React/Vite em modo desenvolvimento
# - Testes Cypress em Chrome e Firefox
#
# üîß SERVI√áOS CONFIGURADOS:
# - MySQL: localhost:3306 (carpool_test_e2e)
# - RabbitMQ: localhost:5672 + Management:15672
# - Backend: localhost:8080 (Spring Boot)
# - Frontend: localhost:5173 (Vite Dev Server)
#
# üìä MONITORAMENTO:
# - Health checks para todos os servi√ßos
# - Logs detalhados salvos como artefatos
# - Screenshots/v√≠deos em caso de falha
# - Coment√°rios autom√°ticos em PRs
# - Resumo detalhado no GitHub Actions