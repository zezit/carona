# .github/workflows/frontEndWeb-e2e.yml
# ðŸ§ª Testes E2E FrontEndWeb com Cypress

name: Testes E2E ðŸ§ª - FrontEndWeb

on:
  push:
    paths:
      - 'code/frontEndWeb/**'
      - 'code/backend/**'  # Backend tambÃ©m afeta E2E
      - 'code/frontEndWeb/cypress/**'
    branches-ignore:
      - 'dependabot/**'
  pull_request:
    paths:
      - 'code/frontEndWeb/**'
      - 'code/backend/**'
      - 'code/frontEndWeb/cypress/**'

env:
  # ConfiguraÃ§Ãµes do ambiente de teste
  FRONTENDWEB_URL: http://localhost:5173
  BACKEND_URL: http://localhost:8080
  DB_HOST: localhost
  DB_PORT: 3306
  DB_NAME: carpool_test_e2e
  DB_USERNAME: test_user
  DB_PASSWORD: test_password
  DB_ROOT_PASSWORD: root_password
  
  # ConfiguraÃ§Ãµes especÃ­ficas do Cypress
  CYPRESS_baseUrl: http://localhost:5173
  CYPRESS_apiUrl: http://localhost:8080/api
  CYPRESS_adminEmail: admin@carona.com
  CYPRESS_adminPassword: admin123
  CYPRESS_adminHashedPassword: '$2a$10$8RdQFz7J9GqVQ4ZxFzQJZuNnQqQJrQrL5rQxKxqF1xLnNnLjYKqJ2'
  
  # ConfiguraÃ§Ãµes do CI
  CI: true
  NODE_ENV: test

jobs:
  # ðŸŽ¯ Testes rÃ¡pidos de smoke
  smoke-tests:
    if: (github.event_name != 'pull_request' && ! github.event.pull_request.head.repo.fork) || (github.event_name == 'pull_request' && (github.event.pull_request.head.repo.fork || startsWith(github.head_ref, 'dependabot/')))
    runs-on: ubuntu-latest
    name: ðŸŽ¯ Smoke Tests
    
    permissions:
      contents: read
      checks: write
      pull-requests: write

    steps:
      - name: ðŸ“¥ Checando cÃ³digo fonte
        uses: actions/checkout@v4

      - name: ðŸŸ¢ Configurando Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: ðŸ“¦ Instalando dependÃªncias do FrontEndWeb
        working-directory: ./code/frontEndWeb
        run: |
          # Verificar se package-lock.json existe
          if [ ! -f "package-lock.json" ]; then
            echo "âŒ package-lock.json nÃ£o encontrado. Executando npm install..."
            npm install
          else
            echo "âœ… package-lock.json encontrado. Executando npm ci..."
            npm ci
          fi

      - name: ðŸ§ª Executando Smoke Tests
        working-directory: ./code/frontEndWeb
        run: |
          # Build da aplicaÃ§Ã£o primeiro
          echo "ðŸ—ï¸ Building aplicaÃ§Ã£o..."
          npm run build
          
          # Iniciar preview da aplicaÃ§Ã£o para smoke tests
          echo "ðŸŒ Iniciando preview..."
          nohup npm run preview > ../smoke-preview.log 2>&1 &
          
          # Aguardar preview estar pronto
          echo "â³ Aguardando preview estar pronto..."
          timeout 30 bash -c 'until curl -f http://localhost:4173 2>/dev/null; do sleep 1; done' || {
            echo "âŒ Preview nÃ£o ficou pronto. Logs:"
            tail -10 ../smoke-preview.log
            exit 1
          }
          echo "âœ… Preview estÃ¡ pronto!"
          
          # Executar apenas testes bÃ¡sicos sem backend
          echo "ðŸ§ª Executando smoke tests..."
          npx cypress run \
            --spec "cypress/e2e/auth/login.cy.js" \
            --browser chrome \
            --headless \
            --config "baseUrl=http://localhost:4173,video=false,screenshotOnRunFailure=true,defaultCommandTimeout=5000" \
            --env "skipApiTests=true,CI=true" || {
            echo "âŒ Smoke tests falharam"
            echo "ðŸ“‹ Logs do preview:"
            tail -20 ../smoke-preview.log
            exit 1
          }
          echo "âœ… Smoke tests concluÃ­dos!"

      - name: ðŸ“Š Upload de artefatos em caso de falha
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: smoke-test-artifacts
          path: |
            code/frontEndWeb/cypress/screenshots
            code/frontEndWeb/cypress/videos
          retention-days: 3

  # ðŸ§ª Testes E2E completos
  e2e-tests:
    if: (github.event_name != 'pull_request' && ! github.event.pull_request.head.repo.fork) || (github.event_name == 'pull_request' && (github.event.pull_request.head.repo.fork || startsWith(github.head_ref, 'dependabot/')))
    runs-on: ubuntu-latest
    name: ðŸ§ª E2E Tests
    
    permissions:
      contents: read
      checks: write
      pull-requests: write
      statuses: write

    # ðŸ“‹ EstratÃ©gia de matriz para diferentes browsers
    strategy:
      fail-fast: false
      matrix:
        browser: [chrome, firefox]
        include:
          - browser: chrome
            port_offset: 0
          - browser: firefox
            port_offset: 10

    steps:
      - name: ðŸ“¥ Checando cÃ³digo fonte
        uses: actions/checkout@v4

      - name: ðŸ”§ Configurando portas dinÃ¢micas
        run: |
          # Calcular portas baseadas no offset da matrix
          PORT_OFFSET=${{ matrix.port_offset }}
          
          # Calcular portas dinÃ¢micas
          MYSQL_PORT=$((3306 + PORT_OFFSET))
          RABBITMQ_PORT=$((5672 + PORT_OFFSET))
          RABBITMQ_MGMT_PORT=$((15672 + PORT_OFFSET))
          BACKEND_PORT=$((8080 + PORT_OFFSET))
          
          # Salvar como variÃ¡veis de ambiente para prÃ³ximos steps
          echo "MYSQL_PORT=$MYSQL_PORT" >> $GITHUB_ENV
          echo "RABBITMQ_PORT=$RABBITMQ_PORT" >> $GITHUB_ENV
          echo "RABBITMQ_MGMT_PORT=$RABBITMQ_MGMT_PORT" >> $GITHUB_ENV
          echo "BACKEND_PORT=$BACKEND_PORT" >> $GITHUB_ENV
          
          echo "ðŸ”§ Portas configuradas:"
          echo "  MySQL: $MYSQL_PORT"
          echo "  RabbitMQ: $RABBITMQ_PORT"
          echo "  RabbitMQ Management: $RABBITMQ_MGMT_PORT"
          echo "  Backend: $BACKEND_PORT"

      - name: ðŸŸ¢ Configurando Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: ðŸ³ Instalando Docker Compose
        run: |
          # Verificar se docker compose estÃ¡ disponÃ­vel
          if ! docker compose version >/dev/null 2>&1; then
            echo "Docker Compose V2 nÃ£o encontrado, instalando docker-compose..."
            sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            echo "docker-compose instalado:"
            docker-compose --version
          else
            echo "Docker Compose V2 disponÃ­vel:"
            docker compose version
          fi

      - name: â˜• Configurando JDK 21
        uses: actions/setup-java@v4
        with: 
          distribution: 'temurin'
          java-version: '21'

      - name: ðŸ”§ Configurando cache do Maven
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven

      - name: ðŸ“¦ Instalando dependÃªncias do FrontEndWeb
        working-directory: ./code/frontEndWeb
        run: |
          echo "ðŸ” Debug: Verificando estrutura de arquivos..."
          pwd
          ls -la
          echo "ðŸ“¦ Verificando package.json e package-lock.json..."
          ls -la package* || echo "Arquivos package nÃ£o encontrados"
          
          # Verificar se package-lock.json existe
          if [ ! -f "package-lock.json" ]; then
            echo "âŒ package-lock.json nÃ£o encontrado. Executando npm install..."
            npm install
          else
            echo "âœ… package-lock.json encontrado. Executando npm ci..."
            npm ci
          fi
          npm run build

      - name: ðŸ³ Iniciando serviÃ§os Docker
        run: |
          # Verificar se arquivo docker-compose existe
          if [ ! -f "docker-compose-e2e.yml" ]; then
            echo "âŒ Arquivo docker-compose-e2e.yml nÃ£o encontrado"
            echo "ðŸ“‚ ConteÃºdo do diretÃ³rio atual:"
            pwd
            ls -la
            exit 1
          fi
          
          # Iniciar serviÃ§os com portas dinÃ¢micas
          docker compose -f docker-compose-e2e.yml up -d
          
          # FunÃ§Ã£o para verificar saÃºde de serviÃ§os especÃ­ficos
          check_service() {
            local service=$1
            local max_attempts=30
            local attempt=1
            
            echo "Verificando serviÃ§o: $service"
            while [ $attempt -le $max_attempts ]; do
              if docker compose -f docker-compose-e2e.yml ps $service | grep -q "healthy"; then
                echo "âœ… $service estÃ¡ saudÃ¡vel"
                return 0
              fi
              echo "â³ Tentativa $attempt/$max_attempts - Aguardando $service..."
              sleep 4
              attempt=$((attempt + 1))
            done
            
            echo "âŒ $service nÃ£o ficou saudÃ¡vel apÃ³s $max_attempts tentativas"
            docker compose -f docker-compose-e2e.yml logs $service
            return 1
          }
          
          # Verificar cada serviÃ§o individualmente
          for service in mysql rabbitmq; do
            if ! check_service $service; then
              echo "âŒ Falha ao inicializar $service"
              docker compose -f docker-compose-e2e.yml logs
              docker compose -f docker-compose-e2e.yml down -v
              exit 1
            fi
          done
          
          echo "âœ… Todos os serviÃ§os estÃ£o saudÃ¡veis!"
          docker compose -f docker-compose-e2e.yml ps
        env:
          DB_ROOT_PASSWORD: ${{ env.DB_ROOT_PASSWORD || 'root_password' }}
          DB_NAME: ${{ env.DB_NAME || 'carpool_test_e2e' }}
          DB_USERNAME: ${{ env.DB_USERNAME || 'test_user' }}
          DB_PASSWORD: ${{ env.DB_PASSWORD || 'test_password' }}
          DB_PORT: ${{ env.MYSQL_PORT || '3306' }}
          RABBITMQ_PORT: ${{ env.RABBITMQ_PORT || '5672' }}
          RABBITMQ_MGMT_PORT: ${{ env.RABBITMQ_MGMT_PORT || '15672' }}

      - name: ðŸŒ± Preparando dados de teste
        run: |
          echo "Verificando conectividade com MySQL..."
          
          # FunÃ§Ã£o para tentar conexÃ£o MySQL com retry
          try_mysql_connection() {
            local max_attempts=30
            local attempt=1
            local wait_time=5
            
            while [ $attempt -le $max_attempts ]; do
              echo "Tentativa $attempt de $max_attempts para conectar ao MySQL..."
              
              if mysql --protocol=TCP -h localhost -P $MYSQL_PORT -u root -p${{ env.DB_ROOT_PASSWORD }} \
                 -e "SELECT 1" > /dev/null 2>&1; then
                echo "âœ… ConexÃ£o MySQL estabelecida!"
                return 0
              fi
              
              echo "â³ Aguardando $wait_time segundos antes da prÃ³xima tentativa..."
              sleep $wait_time
              attempt=$((attempt + 1))
            done
            
            echo "âŒ NÃ£o foi possÃ­vel estabelecer conexÃ£o com MySQL apÃ³s $max_attempts tentativas"
            return 1
          }
          
          # Tentar estabelecer conexÃ£o
          if ! try_mysql_connection; then
            echo "âŒ Erro conectando ao MySQL. Verificando status dos containers..."
            docker compose -f docker-compose-e2e.yml logs mysql
            exit 1
          fi
          
          # Preparar banco de dados
          mysql --protocol=TCP -h localhost -P $MYSQL_PORT -u root -p${{ env.DB_ROOT_PASSWORD }} -e "
            CREATE DATABASE IF NOT EXISTS ${{ env.DB_NAME }};
            CREATE USER IF NOT EXISTS '${{ env.DB_USERNAME }}'@'%' IDENTIFIED BY '${{ env.DB_PASSWORD }}';
            GRANT ALL PRIVILEGES ON ${{ env.DB_NAME }}.* TO '${{ env.DB_USERNAME }}'@'%';
            FLUSH PRIVILEGES;
            USE ${{ env.DB_NAME }};
          "
          
          echo "âœ… Dados de teste preparados!"

      - name: ðŸš€ Iniciando Backend
        working-directory: ./code/backend
        env:
          SUPABASE_API_KEY: dummy-key-for-testing
          SUPABASE_PROJECT_CODE: dummy-project
          SUPABASE_USERPHOTOS_BUCKET_NAME: userphotos
        run: |
          # Compilar aplicaÃ§Ã£o primeiro
          mvn clean compile -DskipTests -q
          
          # Criar arquivo temporÃ¡rio de credenciais FCM para testes
          echo '{"type": "service_account","project_id": "dummy"}' > dummy-credentials.json
          
          # Iniciar aplicaÃ§Ã£o em background com perfil customizado para E2E
          nohup mvn spring-boot:run \
            -Dspring-boot.run.jvmArguments="\
              -Dspring.profiles.active=e2e \
              -Dspring.datasource.url=jdbc:mysql://localhost:$MYSQL_PORT/${{ env.DB_NAME }} \
              -Dspring.datasource.username=${{ env.DB_USERNAME }} \
              -Dspring.datasource.password=${{ env.DB_PASSWORD }} \
              -Dspring.rabbitmq.host=localhost \
              -Dspring.rabbitmq.port=$RABBITMQ_PORT \
              -Dspring.rabbitmq.username=guest \
              -Dspring.rabbitmq.password=guest \
              -Dspring.rabbitmq.virtual-host=/ \
              -Dsupabase.api-key=${SUPABASE_API_KEY} \
              -Dsupabase.code=${SUPABASE_PROJECT_CODE} \
              -Dsupabase.userphotos-bucket-name=${SUPABASE_USERPHOTOS_BUCKET_NAME} \
              -Dfcm.credentials-file=dummy-credentials.json \
              -Dfcm.project-name=carona-test \
              -Dfcm.base-url=https://fcm.googleapis.com/v1/ \
              -Dapp.cors.allowed-origins=http://localhost:5173 \
              -Dspring.jpa.hibernate.ddl-auto=create-drop \
              -Dspring.jpa.show-sql=false \
              -Dlogging.level.com.br.puc.carona=INFO \
              -Dserver.port=$BACKEND_PORT" \
            > ../backend.log 2>&1 &
          
          # Aguardar backend estar pronto
          echo "Aguardando backend estar pronto na porta $BACKEND_PORT..."
          timeout 120 bash -c "until curl -f http://localhost:$BACKEND_PORT/actuator/health 2>/dev/null; do sleep 2; done" || {
            echo "Backend nÃ£o ficou pronto a tempo. Verificando logs..."
            tail -50 ../backend.log
            exit 1
          }
          echo "Backend estÃ¡ pronto!"
        timeout-minutes: 5

      - name: ðŸŒ Iniciando FrontEndWeb
        working-directory: ./code/frontEndWeb
        run: |
          # Configurar variÃ¡vel de ambiente para apontar para o backend com porta dinÃ¢mica
          export VITE_API_BASE_URL="http://localhost:$BACKEND_PORT"
          
          # Iniciar frontEndWeb em background  
          nohup npm run dev -- --host 0.0.0.0 --port 5173 > ../frontEndWeb.log 2>&1 &
          
          # Aguardar frontEndWeb estar pronto
          echo "Aguardando frontend estar pronto..."
          timeout 60 bash -c 'until curl -f http://localhost:5173 2>/dev/null; do sleep 2; done' || {
            echo "Frontend nÃ£o ficou pronto a tempo. Verificando logs..."
            tail -50 ../frontEndWeb.log
            exit 1
          }
          echo "FrontEndWeb estÃ¡ pronto!"
        timeout-minutes: 3

      - name: ðŸ§ª Executando testes Cypress
        uses: cypress-io/github-action@v6
        with:
          working-directory: ./code/frontEndWeb
          install: false
          command: |
            # Verificar se serviÃ§os estÃ£o respondendo antes dos testes
            echo "ðŸ” Verificando serviÃ§os antes dos testes..."
            
            # Verificar frontend
            if ! curl -f http://localhost:5173 >/dev/null 2>&1; then
              echo "âŒ Frontend nÃ£o estÃ¡ respondendo"
              echo "ðŸ“‹ Logs do frontend:"
              tail -20 ../frontEndWeb.log
              exit 1
            fi
            echo "âœ… Frontend estÃ¡ respondendo"
            
            # Verificar backend
            if ! curl -f http://localhost:$BACKEND_PORT/actuator/health >/dev/null 2>&1; then
              echo "âŒ Backend nÃ£o estÃ¡ respondendo na porta $BACKEND_PORT"
              echo "ðŸ“‹ Logs do backend:"
              tail -20 ../backend.log
              exit 1
            fi
            echo "âœ… Backend estÃ¡ respondendo na porta $BACKEND_PORT"
            
            # Verificar MySQL
            if ! mysqladmin ping -h localhost -P $MYSQL_PORT --silent; then
              echo "âŒ MySQL nÃ£o estÃ¡ respondendo na porta $MYSQL_PORT"
              exit 1
            fi
            echo "âœ… MySQL estÃ¡ respondendo na porta $MYSQL_PORT"
            
            # Verificar RabbitMQ
            if ! curl -f http://localhost:$RABBITMQ_MGMT_PORT >/dev/null 2>&1; then
              echo "âŒ RabbitMQ Management nÃ£o estÃ¡ respondendo na porta $RABBITMQ_MGMT_PORT"
              exit 1
            fi
            echo "âœ… RabbitMQ estÃ¡ respondendo na porta $RABBITMQ_MGMT_PORT"
            
            echo "ðŸš€ Todos os serviÃ§os estÃ£o prontos! Iniciando testes..."
            
            # Executar testes Cypress com portas dinÃ¢micas
            npx cypress run \
              --browser ${{ matrix.browser }} \
              --config "baseUrl=http://localhost:5173,defaultCommandTimeout=10000,requestTimeout=15000,responseTimeout=15000,video=true,screenshotOnRunFailure=true" \
              --env "apiUrl=http://localhost:$BACKEND_PORT,adminEmail=${{ env.CYPRESS_adminEmail }},adminPassword=${{ env.CYPRESS_adminPassword }},CI=true"
        env:
          CYPRESS_baseUrl: ${{ env.CYPRESS_baseUrl }}
          CYPRESS_apiUrl: http://localhost:${{ env.BACKEND_PORT }}
          CYPRESS_adminEmail: ${{ env.CYPRESS_adminEmail }}
          CYPRESS_adminPassword: ${{ env.CYPRESS_adminPassword }}
          CI: true

      - name: ðŸ“Š Upload de artefatos Cypress
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: cypress-artifacts-${{ matrix.browser }}
          path: |
            code/frontEndWeb/cypress/videos
            code/frontEndWeb/cypress/screenshots
          retention-days: 7

      - name: ðŸ“ Upload de logs dos servidores
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: server-logs-${{ matrix.browser }}
          path: |
            backend.log
            frontEndWeb.log
          retention-days: 3

      - name: ðŸ“‹ Comentando resultados no PR
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request' && (success() || failure())
        with:
          script: |
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('ðŸ§ª Resultados dos Testes E2E')
            );
            
            const status = '${{ job.status }}' === 'success' ? 'âœ… PASSOU' : 'âŒ FALHOU';
            const emoji = '${{ job.status }}' === 'success' ? 'ðŸŽ‰' : 'ðŸ’¥';
            
            const body = `## ðŸ§ª Resultados dos Testes E2E - ${{ matrix.browser }}
            
            **Status**: ${status}
            **Browser**: ${{ matrix.browser }}
            **Commit**: ${context.sha.substring(0, 7)}
            **Workflow**: [Ver detalhes](${context.payload.repository.html_url}/actions/runs/${context.runId})
            
            ${
              '${{ job.status }}' !== 'success' 
                ? 'ðŸ“Š Verifique os artefatos para vÃ­deos e screenshots das falhas.' 
                : 'ðŸŽ‰ Todos os testes passaram com sucesso!'
            }
            
            ### ðŸ“‹ SuÃ­tes Testadas
            - ðŸ” AutenticaÃ§Ã£o e Login
            - ðŸ  Dashboard Principal  
            - ðŸ‘¥ AprovaÃ§Ã£o de UsuÃ¡rios
            - ðŸ‘¤ Gerenciamento de UsuÃ¡rios
            - ðŸ“Š MÃ©tricas e RelatÃ³rios
            
            ${emoji}
            `;
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      - name: ðŸ“ˆ Gerando resumo dos testes
        if: always()
        run: |
          echo "## ðŸ§ª Resumo dos Testes E2E" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| InformaÃ§Ã£o | Valor |" >> $GITHUB_STEP_SUMMARY
          echo "| ---------- | ----- |" >> $GITHUB_STEP_SUMMARY
          echo "| Browser | ${{ matrix.browser }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Port Offset | ${{ matrix.port_offset }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Status | ${{ job.status == 'success' && 'âœ… Passou' || 'âŒ Falhou' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| FrontEndWeb | http://localhost:5173 |" >> $GITHUB_STEP_SUMMARY
          echo "| Backend | http://localhost:$BACKEND_PORT |" >> $GITHUB_STEP_SUMMARY
          echo "| Database | MySQL 8.0 (port $MYSQL_PORT) |" >> $GITHUB_STEP_SUMMARY
          echo "| RabbitMQ | 3-management (port $RABBITMQ_MGMT_PORT) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" != "success" ]; then
            echo "### ðŸ” Debug" >> $GITHUB_STEP_SUMMARY
            echo "- Verifique os logs dos servidores nos artefatos" >> $GITHUB_STEP_SUMMARY
            echo "- Screenshots e vÃ­deos estÃ£o disponÃ­veis para anÃ¡lise" >> $GITHUB_STEP_SUMMARY
            echo "- Execute localmente: \`npm run cypress:web\`" >> $GITHUB_STEP_SUMMARY
            echo "- Logs de debug: backend.log, frontEndWeb.log" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ðŸŽ‰ Sucesso!" >> $GITHUB_STEP_SUMMARY
            echo "Todos os testes E2E passaram com sucesso!" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Frontend funcionando corretamente" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Backend respondendo adequadamente" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… IntegraÃ§Ã£o MySQL funcionando" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… RabbitMQ configurado corretamente" >> $GITHUB_STEP_SUMMARY
          fi

      - name: ðŸ§¹ Limpeza dos recursos Docker
        if: always()
        run: |
          echo "Parando e removendo containers Docker..."
          docker compose -f docker-compose-e2e.yml down -v --remove-orphans || true
          
          # Remover volumes Ã³rfÃ£os
          docker volume prune -f || true
          
          echo "âœ… Limpeza concluÃ­da!"

# ðŸ“‹ RESUMO DO PIPELINE E2E:
# 
# Este workflow executa testes end-to-end completos para o sistema carpool:
#
# ðŸŽ¯ SMOKE TESTS:
# - Testa apenas o frontend em modo preview
# - NÃ£o requer backend/database
# - ExecuÃ§Ã£o rÃ¡pida para validaÃ§Ã£o bÃ¡sica
#
# ðŸ§ª E2E TESTS COMPLETOS:
# - MySQL 8.0 como banco de dados
# - RabbitMQ 3-management para mensageria  
# - Backend Spring Boot com perfil E2E
# - Frontend React/Vite em modo desenvolvimento
# - Testes Cypress em Chrome e Firefox
#
# ðŸ”§ SERVIÃ‡OS CONFIGURADOS:
# - MySQL: localhost:3306 (carpool_test_e2e)
# - RabbitMQ: localhost:5672 + Management:15672
# - Backend: localhost:8080 (Spring Boot)
# - Frontend: localhost:5173 (Vite Dev Server)
#
# ðŸ“Š MONITORAMENTO:
# - Health checks para todos os serviÃ§os
# - Logs detalhados salvos como artefatos
# - Screenshots/vÃ­deos em caso de falha
# - ComentÃ¡rios automÃ¡ticos em PRs
# - Resumo detalhado no GitHub Actions